<!DOCTYPE html>
<html id="top">
<head>
    <meta charset="utf-8">
    
    <title>016-使用Module(模块)组织依赖关系-《用AngularJS开发下一代Web应用》-笔记 | Xiguaaxigua</title>
    
    <meta name="author" content="zhiyuan.liu">
    
    
    <meta name="description" content="前端技术, web开发, 交流分享, javascript, hexo, blog">
    
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <meta property="og:title" content="016-使用Module(模块)组织依赖关系-《用AngularJS开发下一代Web应用》-笔记"/>
    
    <meta property="og:site_name" content="Xiguaaxigua"/>
    
    <meta property="og:image" content="undefined"/>
    
    <link href="http://xigua.image.alimmdn.com/favicon.ico?t=1475142583830" rel="shortcut icon">
    <link href="/css/xiguaaxigua.css" rel="stylesheet">
    <link href="/css/captionjs.min.css" rel="stylesheet"/>
    <link href="/css/prettify.css" rel="stylesheet">
    <script type="text/javascript" src="/js/prettify.js"></script>
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/jquery.caption.min.js"></script>
    <script type="text/javascript" src="/js/xiguaaxigua.js"></script>

    
</head>

<body>
  <header class="header">
    <img class="logo" src="http://xigua.image.alimmdn.com/Xigua-about-me.jpg?t=1470201154036" alt="">
    <a class="fold" href="#top"></a>
    <div class="menu">
        <h1 class="header-title">Xiguaaxigua</h1>
        <p class="header-desc">Web Developer and Obsessive</p>
        <nav class="nav">
            <div class="nav-group">
                
                <a class="nav-item" href="/">Home</a>
                
                <a class="nav-item" href="/archives">Archives</a>
                
                <a class="nav-item" href="/messages">Messages</a>
                
            </div>
        </nav>
    </div>
</header>


  <div class="post">
      
<h2 class="post-title">016-使用Module(模块)组织依赖关系-《用AngularJS开发下一代Web应用》-笔记</h2>
<p class="post-info">
    <i class="icon icon-clock"></i>
    <time datetime="2016-05-12T13:24:58.000Z">05/12/2016</time>
    

<i class="icon icon-tag"></i>
<a class="tag-a" href="/tags/Angular/">Angular</a>, <a class="tag-a" href="/tags/读书笔记/">读书笔记</a>

</p>

<div class="post-content">
    </p>
<h3 id="使用Module-模块-组织依赖关系"><a href="#使用Module-模块-组织依赖关系" class="headerlink" title="使用Module(模块)组织依赖关系"></a>使用Module(模块)组织依赖关系</h3><p>开发任何一款优秀的应用都会面临一项非常困难的工作，那就是找到一种方式把代码组织在合适的功能范围内。我们已经看到控制器的处理方式，它会提供一块空间，把正确的数据模型和函数暴露给视图模板。但是其他那些用来支撑我们应用的代码应该怎么办呢？有一块最明显的可以放这些代码的地方，那就是控制器中的函数。</p>
<p>这种做法对于小型的应用和例子来说可以工作得很好，我们已经看到过很多这样的例子，但是在真实的应用中，这种做法很快就会使代码变得无法维护。控制器将会变成一个垃圾场，我们要做的所有东西都会倒在里面。它们会非常难以理解，并且非常难以修改。</p>
<p>我们来看模块。它们提供了一种方法，可以用来组织应用中一块功能区域的依赖关系；同时还提供了一种机制，可以自动解析依赖关系（又叫做依赖注入）。一般来说，我们把这些叫做依赖服务，因为它们会负责为应用提供特殊的服务。</p>
<p>例如，如果购物站点中的一个控制器需要从服务器上获取一个商品列表，那么我们就需要某些对象——不妨把它叫做Items——来处理从服务器端获取商品的工作。进而，Items对象就需要以某种方式与服务器上的数据库进行交互，可以通过XHR或者WebSocket。</p>
<p>如果在没有模块的情况下做这些事情，那么代码看起来就像下面这样：</p>
<pre><code>function ItemsViewController($scope){
    //向服务器发起请求
    ...
    //解析响应并放入Item对象
    ...
    //Items数组设置到$scope上，这样视图才能够显示它
    ...
}
</code></pre><p>虽然这样做确实可以运行，但是却存在大量潜在的问题。</p>
<ul>
<li>如果其他控制器也需要从服务端获取Items，那么我们只能把这段代码重写一遍。这会给维护工作造成很大负担，因为如果修改了架构或者其他东西，那么我们就必须在很多地方修改同一代码。</li>
<li>加上其他一些因素，例如服务端认证、解析数据的复杂性等，会使得控制器对象很难划分出一个合理的功能边界，并且代码阅读起来更加困难。</li>
<li>为了对这段代码进行单元测试，我们需要真正启动一个服务器，或者对XMLHttpRequest进行模拟，从而返回一些假数据。真正运行一个服务器会让测试过程变得很慢，配置服务器很痛苦，而且给测试工作带来不可靠性。模拟路由的方式可以解决运行速度和不可靠测试的问题，但是这意味着，你必须在两次测试之间去掉被模拟对象上的模拟内容，同时它还会带来额外的复杂度和弱点，因为它会强制给你的数据指定一个“线上”形式（并且当这个形式发生变化时需要同时修改测试代码）。</li>
</ul>
<p>利用模块和模块内置的依赖注入功能，我们就可以把控制器写的更加简单，示例如下：</p>
<pre><code>function ShoppingController($scope, Items){
    $scope.items = Items.query();
}
</code></pre><p>现在你可能会问自己，“不错，这样看起来很酷，但是Items这个对象上是从哪儿来的呢？”以上代码假设我们已经把Items对象定义成了一个服务。</p>
<p>Angular内置了很多服务，例如$location服务，用来和浏览器的地址栏进行交互；$route服务，用来根据URL地址的变化切换视图；还有$http服务，用来和服务器进行交互。</p>
<p>你可以并且也应该去创建自己的服务，用它们来实现你的应用所特有的功能。如果需要，服务可以在任何控制器之间进行互享。因此，当你需要在多个控制器之间进行交互和共享状态时，这些服务就是一种很好的机制。Angular内置的服务以$符号打头，你当然可以给你的服务随意起名字，但是最好不要以$开头，以免引起命名冲突。</p>
<p>你可以使用模型对象的API来定义服务。以下3个函数可以用来创建一般的服务，它们的复杂度和功能不同。</p>
<h4 id="provider-name-Object-OR-construtor"><a href="#provider-name-Object-OR-construtor" class="headerlink" title="provider(name, Object OR construtor())"></a>provider(name, Object OR construtor())</h4><p>函数：provider(name, Object OR construtor())<br>定义：一个可配置的服务，创建的逻辑比较复杂。如果你传递了一个Object作为参数，那么这个Object对象必须带有一个名为$get的函数，这个函数需要返回服务的名称。否则，Angular会认为你传递的是一个构造函数，调用构造函数会返回服务实例对象。</p>
<h4 id="factory-name-getFunction"><a href="#factory-name-getFunction" class="headerlink" title="factory(name, $getFunction())"></a>factory(name, $getFunction())</h4><p>函数：factory(name, $getFunction())<br>定义：一个不可配置服务，创建逻辑比较复杂。你需要指定一个函数，当调用这个函数的时候，会返回服务的实例。你可以把它看成provider(name, {$get: $getFuntion})的形式。</p>
<h4 id="service-name-construtor"><a href="#service-name-construtor" class="headerlink" title="service(name, construtor())"></a>service(name, construtor())</h4><p>函数：service(name, construtor())<br>定义：一个不可配置的服务，创建逻辑比较简单。与上面provider函数的construtor参数类似，Angular调用它可以创建服务实例。</p>
<p>后面我们会解释provider()函数的配置项，我们先来讨论一个针对Item的使用factory()的例子。我们可以像下面这样来编写服务：</p>
<pre><code>//创建一个模型用来支撑我们的购物视图
var shoppingModule = angular.module(&#39;ShoppingModule&#39;, []);

//设置好服务工厂，用来创建我们的Items接口，以便访问服务端数据库
shoppingModule.factory(&#39;Items&#39;, function(){
    var items = {};

    items.query = function(){
        //在真实的应用中，我们会从服务端拉去这些数据...
        return [
            {title: &#39;商品1&#39;, description: &#39;商品1的描述&#39;, price: 1},
            {title: &#39;商品2&#39;, description: &#39;商品2的描述&#39;, price: 2},
            {title: &#39;商品3&#39;, description: &#39;商品3的描述&#39;, price: 3}
        ];
    }
    return items;
});
</code></pre><p>当Angular创建ShoppingController时，它会把$scope对象和刚定义的Items服务作为参数传递进去。这一点是通过参数名匹配来实现的，也就是说，Angular会查看我们的ShoppingController类的函数签名，然后就会发现它需要一个Items对象。既然我们已经把Items定义成了一个服务，那么Angular当然知道去哪里找这个服务了。</p>
<p>以字符串的形式查找这些依赖关系的结果是，可以进行注入的那些函数（例如控制器的构造器）的参数是没有顺序的。所以，除了下面这种写法之外：</p>
<pre><code>function ShoppingController($scope, Items){
    ...
}
</code></pre><p>你还可以这样写：</p>
<pre><code>function ShoppingController(Items, $scope){
    ...
}
</code></pre><p>这种写法同样能够按照我们所期望的方式运行。</p>
<p>为了让这一机制能够和模板配合起来，我们需要把模块名称告诉ng-app指令，示例如下：</p>
<pre><code>&lt;html ng-app=&quot;ShoppingModule&quot;&gt;
</code></pre><p>为了完成这个例子，我们可以把模板的其他部分实现如下：</p>
<pre><code>&lt;body ng-controller=&quot;ShoppingController&quot;&gt;
    &lt;h1&gt;Shop!&lt;/h1&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;{{items.title}}&lt;/td&gt;
            &lt;td&gt;{{items.description}}&lt;/td&gt;
            &lt;td&gt;{{items.price | currency}}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/body&gt;
</code></pre>
</div>

<div class="ds-thread" data-thread-key="2016/05/12/angular-note-016/" data-title="016-使用Module(模块)组织依赖关系-《用AngularJS开发下一代Web应用》-笔记" data-url="http://xiguaaxigua.cn/2016/05/12/angular-note-016/"></div>
<script type="text/javascript">
    var duoshuoQuery = {short_name:"xiguaaxigua"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>

  </div>
  <div class="footer">
    <p class="copyright">
        
        &copy; 2016 zhiyuan.liu
        
    </p>
    <!--<p>
        <span class="count" id="busuanzi_container_site_pv">Hello World！您是本站第<i id="busuanzi_value_site_pv"></i>位访问者</span>
    </p>-->
</div>
<!--<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>-->


  <script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0-wip/js/bootstrap.min.js"></script>






</body>
</html>