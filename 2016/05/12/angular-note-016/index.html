<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>016-使用Module(模块)组织依赖关系-《用AngularJS开发下一代Web应用》-笔记 | Xiguaaxigua</title>
  <meta name="author" content="Zhiyuan.liu">
  
  <meta name="description" content="前端技术,web开发,交流分享,javascript,hexo,blog">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta property="og:title" content="016-使用Module(模块)组织依赖关系-《用AngularJS开发下一代Web应用》-笔记"/>
  <meta property="og:site_name" content="Xiguaaxigua"/>
  
  <meta property="og:image" content="undefined"/>
  
  <link href="/favicon.png" rel="shortcut icon">
  <link rel="alternate" href="/atom.xml" title="Xiguaaxigua" type="application/atom+xml">
  <link href="/css/site.css" rel="stylesheet">
  <link href="/css/captionjs.min.css" rel="stylesheet"/>
  <link href="/css/prettify.css" rel="stylesheet">
  <script type="text/javascript" src="/js/prettify.js"></script>
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <script type="text/javascript" src="/js/jquery.caption.min.js"></script>
  <script type="text/javascript" src="/js/xiguaaxigua.js"></script>

  
</head>

<body>
  

<div class="navbar navbar-default navbar-static-top">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/"><span class="text-primary">Xiguaaxigua</span></a>
    </div>
    <div class="collapse navbar-collapse navbar-right">
      <ul class="nav navbar-nav">
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/archives">归档</a></li>
        
          <li><a href="/history">历史</a></li>
        
          <li><a href="/messages">留言</a></li>
        
      </ul>
      <ul class="nav navbar-nav pull-right">
      
      
      
      
      </ul>
    </div>
  </div>
</div>


  <div class="container">
    <div class="row">
      <div class="col-md-12"><article class="post">
  
    
  
    <h1 class="title">016-使用Module(模块)组织依赖关系-《用AngularJS开发下一代Web应用》-笔记</h1>
  

    <div class="post-date">
      <time datetime="2016-05-12T13:24:58.000Z">2016-05-12</time>
    </div>
    
  
  <div class="tags">
    <a class="tag-a" href="/tags/Angular/">Angular</a>, <a class="tag-a" href="/tags/读书笔记/">读书笔记</a>
  </div>

  
  <div class="post-content">
    
      </p>
<h3 id="使用Module-模块-组织依赖关系"><a href="#使用Module-模块-组织依赖关系" class="headerlink" title="使用Module(模块)组织依赖关系"></a>使用Module(模块)组织依赖关系</h3><p>开发任何一款优秀的应用都会面临一项非常困难的工作，那就是找到一种方式把代码组织在合适的功能范围内。我们已经看到控制器的处理方式，它会提供一块空间，把正确的数据模型和函数暴露给视图模板。但是其他那些用来支撑我们应用的代码应该怎么办呢？有一块最明显的可以放这些代码的地方，那就是控制器中的函数。</p>
<p>这种做法对于小型的应用和例子来说可以工作得很好，我们已经看到过很多这样的例子，但是在真实的应用中，这种做法很快就会使代码变得无法维护。控制器将会变成一个垃圾场，我们要做的所有东西都会倒在里面。它们会非常难以理解，并且非常难以修改。</p>
<p>我们来看模块。它们提供了一种方法，可以用来组织应用中一块功能区域的依赖关系；同时还提供了一种机制，可以自动解析依赖关系（又叫做依赖注入）。一般来说，我们把这些叫做依赖服务，因为它们会负责为应用提供特殊的服务。</p>
<p>例如，如果购物站点中的一个控制器需要从服务器上获取一个商品列表，那么我们就需要某些对象——不妨把它叫做Items——来处理从服务器端获取商品的工作。进而，Items对象就需要以某种方式与服务器上的数据库进行交互，可以通过XHR或者WebSocket。</p>
<p>如果在没有模块的情况下做这些事情，那么代码看起来就像下面这样：</p>
<pre><code>function ItemsViewController($scope){
    //向服务器发起请求
    ...
    //解析响应并放入Item对象
    ...
    //Items数组设置到$scope上，这样视图才能够显示它
    ...
}
</code></pre><p>虽然这样做确实可以运行，但是却存在大量潜在的问题。</p>
<ul>
<li>如果其他控制器也需要从服务端获取Items，那么我们只能把这段代码重写一遍。这会给维护工作造成很大负担，因为如果修改了架构或者其他东西，那么我们就必须在很多地方修改同一代码。</li>
<li>加上其他一些因素，例如服务端认证、解析数据的复杂性等，会使得控制器对象很难划分出一个合理的功能边界，并且代码阅读起来更加困难。</li>
<li>为了对这段代码进行单元测试，我们需要真正启动一个服务器，或者对XMLHttpRequest进行模拟，从而返回一些假数据。真正运行一个服务器会让测试过程变得很慢，配置服务器很痛苦，而且给测试工作带来不可靠性。模拟路由的方式可以解决运行速度和不可靠测试的问题，但是这意味着，你必须在两次测试之间去掉被模拟对象上的模拟内容，同时它还会带来额外的复杂度和弱点，因为它会强制给你的数据指定一个“线上”形式（并且当这个形式发生变化时需要同时修改测试代码）。</li>
</ul>
<p>利用模块和模块内置的依赖注入功能，我们就可以把控制器写的更加简单，示例如下：</p>
<pre><code>function ShoppingController($scope, Items){
    $scope.items = Items.query();
}
</code></pre><p>现在你可能会问自己，“不错，这样看起来很酷，但是Items这个对象上是从哪儿来的呢？”以上代码假设我们已经把Items对象定义成了一个服务。</p>
<p>Angular内置了很多服务，例如$location服务，用来和浏览器的地址栏进行交互；$route服务，用来根据URL地址的变化切换视图；还有$http服务，用来和服务器进行交互。</p>
<p>你可以并且也应该去创建自己的服务，用它们来实现你的应用所特有的功能。如果需要，服务可以在任何控制器之间进行互享。因此，当你需要在多个控制器之间进行交互和共享状态时，这些服务就是一种很好的机制。Angular内置的服务以$符号打头，你当然可以给你的服务随意起名字，但是最好不要以$开头，以免引起命名冲突。</p>
<p>你可以使用模型对象的API来定义服务。以下3个函数可以用来创建一般的服务，它们的复杂度和功能不同。</p>
<h4 id="provider-name-Object-OR-construtor"><a href="#provider-name-Object-OR-construtor" class="headerlink" title="provider(name, Object OR construtor())"></a>provider(name, Object OR construtor())</h4><p>函数：provider(name, Object OR construtor())<br>定义：一个可配置的服务，创建的逻辑比较复杂。如果你传递了一个Object作为参数，那么这个Object对象必须带有一个名为$get的函数，这个函数需要返回服务的名称。否则，Angular会认为你传递的是一个构造函数，调用构造函数会返回服务实例对象。</p>
<h4 id="factory-name-getFunction"><a href="#factory-name-getFunction" class="headerlink" title="factory(name, $getFunction())"></a>factory(name, $getFunction())</h4><p>函数：factory(name, $getFunction())<br>定义：一个不可配置服务，创建逻辑比较复杂。你需要指定一个函数，当调用这个函数的时候，会返回服务的实例。你可以把它看成provider(name, {$get: $getFuntion})的形式。</p>
<h4 id="service-name-construtor"><a href="#service-name-construtor" class="headerlink" title="service(name, construtor())"></a>service(name, construtor())</h4><p>函数：service(name, construtor())<br>定义：一个不可配置的服务，创建逻辑比较简单。与上面provider函数的construtor参数类似，Angular调用它可以创建服务实例。</p>
<p>后面我们会解释provider()函数的配置项，我们先来讨论一个针对Item的使用factory()的例子。我们可以像下面这样来编写服务：</p>
<pre><code>//创建一个模型用来支撑我们的购物视图
var shoppingModule = angular.module(&#39;ShoppingModule&#39;, []);

//设置好服务工厂，用来创建我们的Items接口，以便访问服务端数据库
shoppingModule.factory(&#39;Items&#39;, function(){
    var items = {};

    items.query = function(){
        //在真实的应用中，我们会从服务端拉去这些数据...
        return [
            {title: &#39;商品1&#39;, description: &#39;商品1的描述&#39;, price: 1},
            {title: &#39;商品2&#39;, description: &#39;商品2的描述&#39;, price: 2},
            {title: &#39;商品3&#39;, description: &#39;商品3的描述&#39;, price: 3}
        ];
    }
    return items;
});
</code></pre><p>当Angular创建ShoppingController时，它会把$scope对象和刚定义的Items服务作为参数传递进去。这一点是通过参数名匹配来实现的，也就是说，Angular会查看我们的ShoppingController类的函数签名，然后就会发现它需要一个Items对象。既然我们已经把Items定义成了一个服务，那么Angular当然知道去哪里找这个服务了。</p>
<p>以字符串的形式查找这些依赖关系的结果是，可以进行注入的那些函数（例如控制器的构造器）的参数是没有顺序的。所以，除了下面这种写法之外：</p>
<pre><code>function ShoppingController($scope, Items){
    ...
}
</code></pre><p>你还可以这样写：</p>
<pre><code>function ShoppingController(Items, $scope){
    ...
}
</code></pre><p>这种写法同样能够按照我们所期望的方式运行。</p>
<p>为了让这一机制能够和模板配合起来，我们需要把模块名称告诉ng-app指令，示例如下：</p>
<pre><code>&lt;html ng-app=&quot;ShoppingModule&quot;&gt;
</code></pre><p>为了完成这个例子，我们可以把模板的其他部分实现如下：</p>
<pre><code>&lt;body ng-controller=&quot;ShoppingController&quot;&gt;
    &lt;h1&gt;Shop!&lt;/h1&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;{{items.title}}&lt;/td&gt;
            &lt;td&gt;{{items.description}}&lt;/td&gt;
            &lt;td&gt;{{items.price | currency}}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/body&gt;
</code></pre>
    
  </div>
  
  <div class="addthis_toolbox addthis_default_style 
addthis_32x32_style" data-addthis-url="http://xiguaaxigua.cn/2016/05/12/angular-note-016/" data-addthis-title="016-使用Module(模块)组织依赖关系-《用AngularJS开发下一代Web应用》-笔记">
<a class="addthis_button_preferred_1"></a>
<a class="addthis_button_preferred_2"></a>
<a class="addthis_button_preferred_3"></a>
<a class="addthis_button_preferred_4"></a>
<a class="addthis_button_compact"></a>
<a class="addthis_counter addthis_bubble_style"></a>
</div>
  
    <ul class="next_prev">
      
        <li class="prev">
        <a class="btn btn-success" role="button" href="/2016/05/12/angular-note-015/">
          上一篇
        </a></li>
      
      
        <li class="next">
        <a class="btn btn-success" role="button" href="/2016/05/13/angular-note-017/">
          下一篇
        </a></li>
      
    </ul>
  
  
<div class="ds-thread" data-thread-key="2016/05/12/angular-note-016/" data-title="016-使用Module(模块)组织依赖关系-《用AngularJS开发下一代Web应用》-笔记" data-url="http://xiguaaxigua.cn/2016/05/12/angular-note-016/"></div>
<script type="text/javascript">
    var duoshuoQuery = {short_name:"xiguaaxigua"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>

</article></div>
    </div>
  </div>
  <div id="push"></div>
  <div class="navbar navbar-footer">
  <div class="container">
    <p class="navbar-center navbar-text">
      
      &copy; 2016 Zhiyuan.liu
      
    </p>
    <p class="navbar-center navbar-text" style="margin-top: 0;">
      <span id="busuanzi_container_site_pv">Hello World！您是本站第<span style="color:#1d9531;padding: 0 5px;" id="busuanzi_value_site_pv"></span>位访问者</span>
    </p>
  </div>
</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0-wip/js/bootstrap.min.js"></script>






</body>
</html>